import { Controlled } from "./controlled";
import { FieldAccessor } from "./field-accessor";
export interface StateConverterOptions {
    decimalSeparator?: string;
    thousandSeparator?: string;
    renderThousands?: boolean;
}
export interface StateConverterOptionsWithContext extends StateConverterOptions {
    context?: any;
    accessor: FieldAccessor<any, any>;
}
export interface ConverterOptions<R, V> {
    convert(raw: R, options: StateConverterOptionsWithContext): V;
    render(value: V, options: StateConverterOptionsWithContext): R;
    emptyRaw: R;
    emptyValue?: V;
    emptyImpossible?: boolean;
    defaultControlled?: Controlled;
    neverRequired?: boolean;
    preprocessRaw?(raw: R, options?: StateConverterOptionsWithContext): R;
}
export interface IConverter<R, V> {
    emptyRaw: R;
    emptyValue: V;
    emptyImpossible: boolean;
    convert(raw: R, options: StateConverterOptionsWithContext): ConversionResponse<V>;
    render(value: V, options: StateConverterOptionsWithContext): R;
    defaultControlled: Controlled;
    neverRequired: boolean;
    preprocessRaw(raw: R, options: StateConverterOptionsWithContext): R;
}
export declare class ConversionValue<V> {
    value: V;
    constructor(value: V);
}
export declare class ConversionError {
    type: string;
    constructor(type?: string);
}
export declare type ConversionResponse<V> = ConversionError | ConversionValue<V>;
export declare class Converter<R, V> implements IConverter<R, V> {
    definition: ConverterOptions<R, V>;
    emptyRaw: R;
    emptyValue: V;
    emptyImpossible: boolean;
    defaultControlled: Controlled;
    neverRequired: boolean;
    constructor(definition: ConverterOptions<R, V>);
    preprocessRaw(raw: R, options?: StateConverterOptionsWithContext): R;
    convert(raw: R, options: StateConverterOptionsWithContext): ConversionResponse<V>;
    render(value: V, options: StateConverterOptionsWithContext): R;
}
export interface PartialConverterFactory<O, R, V> {
    (options?: Partial<O>): IConverter<R, V>;
}
export interface ConverterFactory<O, R, V> {
    (options: O): IConverter<R, V>;
}
export declare function withDefaults<O, R, V>(converterFactory: ConverterFactory<O, R, V>, defaults: O): PartialConverterFactory<O, R, V>;
export declare type ConverterOrFactory<R, V> = IConverter<R, V> | (() => IConverter<R, V>);
export declare function makeConverter<R, V>(converter: ConverterOrFactory<R, V>): IConverter<R, V>;
