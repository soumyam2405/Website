import { IAnyModelType, Instance } from "mobx-state-tree";
import { Form, FormDefinition, ValidationResponse, GroupDefinition, ErrorFunc, IDisposer, RepeatingForm } from "./form";
import { FieldAccessor } from "./field-accessor";
import { FormAccessorBase } from "./form-accessor-base";
import { RepeatingFormAccessor } from "./repeating-form-accessor";
import { ValidateOptions } from "./validate-options";
import { StateConverterOptions, StateConverterOptionsWithContext } from "./converter";
import { Backend, ProcessorOptions, Process, SaveFunc, ProcessAll, AccessUpdate } from "./backend";
import { Validation } from "./validationMessages";
import { IAccessor, IFormAccessor, IRepeatingFormAccessor, ISubFormAccessor } from "./interfaces";
export interface AccessorAllows {
    (accessor: IAccessor): boolean;
}
export interface ErrorOrWarning {
    (accessor: IAccessor): string | undefined;
}
export interface ExtraValidation {
    (fieldAccessor: FieldAccessor<any, any>, value: any): ValidationResponse;
}
export interface RepeatingFormAccessorAllows {
    (repeatingFormAccessor: RepeatingFormAccessor<any, any, any>): boolean;
}
export interface EventFunc<R, V> {
    (event: any, accessor: FieldAccessor<R, V>): void;
}
export interface UpdateFunc<R, V> {
    (accessor: FieldAccessor<R, V>): void;
}
export declare type ValidationOption = "immediate" | "no";
export declare type BackendOptions<M> = {
    save?: SaveFunc<M>;
    process?: Process<M>;
    processAll?: ProcessAll<M>;
};
declare type ValidationOptions = {
    beforeSave: ValidationOption;
    afterSave: ValidationOption;
    pauseDuration: number;
};
export interface FormStateOptions<M> {
    addMode?: boolean;
    validation?: Partial<ValidationOptions>;
    isDisabled?: AccessorAllows;
    isHidden?: AccessorAllows;
    isReadOnly?: AccessorAllows;
    isRequired?: AccessorAllows;
    getError?: ErrorOrWarning;
    getWarning?: ErrorOrWarning;
    backend?: BackendOptions<M> & ProcessorOptions;
    extraValidation?: ExtraValidation;
    focus?: EventFunc<any, any>;
    blur?: EventFunc<any, any>;
    update?: UpdateFunc<any, any>;
    context?: any;
    converterOptions?: StateConverterOptions;
    requiredError?: string | ErrorFunc;
    addModeDefaults?: string[];
}
export declare type SaveStatusOptions = "before" | "rightAfter" | "after";
export declare class FormState<D extends FormDefinition<M>, G extends GroupDefinition<D>, M extends IAnyModelType> extends FormAccessorBase<D, G, M> implements IFormAccessor<D, G, M> {
    form: Form<M, D, G>;
    node: Instance<M>;
    saveStatus: SaveStatusOptions;
    validationBeforeSave: ValidationOption;
    validationAfterSave: ValidationOption;
    validationPauseDuration: number;
    isDisabledFunc: AccessorAllows;
    isHiddenFunc: AccessorAllows;
    isReadOnlyFunc: AccessorAllows;
    isRequiredFunc: AccessorAllows;
    getErrorFunc: ErrorOrWarning;
    getWarningFunc: ErrorOrWarning;
    extraValidationFunc: ExtraValidation;
    private noRawUpdate;
    focusFunc: EventFunc<any, any> | undefined;
    blurFunc: EventFunc<any, any> | undefined;
    updateFunc: UpdateFunc<any, any> | undefined;
    processor: Backend<M> | undefined;
    _context: any;
    _converterOptions: StateConverterOptions;
    _requiredError: string | ErrorFunc;
    _onPatchDisposer: IDisposer;
    constructor(form: Form<M, D, G>, node: Instance<M>, { addMode, isDisabled, isHidden, isReadOnly, isRequired, getError, getWarning, backend, extraValidation, validation, focus, blur, update, context, converterOptions, requiredError, addModeDefaults }?: FormStateOptions<M>);
    get state(): this;
    get context(): any;
    dispose(): void;
    createRepeatingFormAccessor(repeatingForm: RepeatingForm<any, any>, parent: IFormAccessor<any, any, any>, name: string): IRepeatingFormAccessor<any, any, any>;
    createSubFormAccessor(definition: any, groupDefinition: any, parent: IFormAccessor<any, any, any>, name: string): ISubFormAccessor<any, any, any>;
    get path(): string;
    get value(): Instance<M>;
    get processPromise(): Promise<void>;
    get liveOnly(): boolean;
    stateConverterOptionsWithContext(accessor: any): StateConverterOptionsWithContext;
    setSaveStatus(status: SaveStatusOptions): void;
    setValueWithoutRawUpdate(path: string, value: any): void;
    replacePath(path: string): void;
    removePath(path: string): void;
    addPath(path: string): void;
    save(options?: ValidateOptions): Promise<boolean>;
    resetSaveStatus(): Promise<void>;
    processAll(liveOnly?: boolean): Promise<void>;
    setExternalValidations(validations: Validation[], messageType: "error" | "warning"): void;
    clearExternalValidations(messageType: "error" | "warning"): void;
    clearAllValidations(): void;
    setAccessUpdate(accessUpdate: AccessUpdate): void;
    getValue(path: string): any;
    accessByPath(path: string): IAccessor | undefined;
    get canShowValidationMessages(): boolean;
}
export {};
