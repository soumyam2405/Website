import { IMSTArray, IAnyModelType, ModelInstanceTypeProps, Instance } from "mobx-state-tree";
import { ConversionError, ConverterOrFactory, IConverter, StateConverterOptionsWithContext } from "./converter";
import { FormState, FormStateOptions } from "./state";
import { Controlled } from "./controlled";
import { Source } from "./source";
import { FieldAccessor } from "./field-accessor";
export declare type ArrayEntryType<T> = T extends IMSTArray<infer A> ? (A extends IAnyModelType ? A : never) : never;
export declare type RawType<F> = F extends Field<infer R, any> ? R : never;
export declare type ValueType<F> = F extends Field<any, infer V> ? V : never;
export declare type RepeatingFormDefinitionType<T> = T extends RepeatingForm<infer D, any> ? D : never;
export declare type RepeatingFormGroupDefinitionType<T> = T extends RepeatingForm<any, infer G> ? G : never;
export declare type SubFormDefinitionType<T> = T extends SubForm<infer D, any> ? D : never;
export declare type SubFormGroupDefinitionType<T> = T extends SubForm<any, infer G> ? G : never;
export declare type FormDefinition<M extends IAnyModelType> = InstanceFormDefinition<Instance<M>>;
export declare type InstanceFormDefinition<M extends ModelInstanceTypeProps<any>> = {
    [K in keyof M]?: Field<any, M[K]> | RepeatingForm<FormDefinition<ArrayEntryType<M[K]>>, any> | SubForm<FormDefinition<M[K]>, any>;
};
export declare type ValidationResponse = string | null | undefined | false;
export interface Validator<V> {
    (value: V, context?: any): ValidationResponse;
}
export interface Derived<V> {
    (node: any): V;
}
export interface Change<V> {
    (node: any, value: V): void;
}
export interface RawGetter<R> {
    (...args: any[]): R;
}
export interface ErrorFunc {
    (context: any): string;
}
export interface AccessorDependentQuery<DQ> {
    (accessor: FieldAccessor<any, any>): DQ;
}
export interface ReferenceOptions<SQ, DQ> {
    source: Source<any, SQ & DQ>;
    dependentQuery?: AccessorDependentQuery<DQ>;
}
export declare type ConversionErrors = {
    default: string | ErrorFunc;
    [key: string]: string | ErrorFunc;
};
export declare type ConversionErrorType = string | ErrorFunc | ConversionErrors;
export interface FieldOptions<R, V, SQ, DQ> {
    getRaw?(...args: any[]): R;
    rawValidators?: Validator<R>[];
    validators?: Validator<V>[];
    conversionError?: ConversionErrorType;
    requiredError?: string | ErrorFunc;
    required?: boolean;
    fromEvent?: boolean;
    derived?: Derived<V>;
    change?: Change<V>;
    controlled?: Controlled;
    references?: ReferenceOptions<SQ, DQ>;
    postprocess?: boolean;
}
export declare type GroupDefinition<D extends FormDefinition<any>> = {
    [key: string]: Group<D>;
};
export declare type IDisposer = () => void;
export declare class Form<M extends IAnyModelType, D extends FormDefinition<M>, G extends GroupDefinition<D>> {
    model: M;
    definition: D;
    groupDefinition?: G | undefined;
    constructor(model: M, definition: D, groupDefinition?: G | undefined);
    get FormStateType(): FormState<D, G, M>;
    state(node: Instance<M>, options?: FormStateOptions<M>): FormState<D, G, M>;
}
export declare class SubForm<D extends FormDefinition<any>, G extends GroupDefinition<D>> {
    definition: D;
    groupDefinition?: G | undefined;
    constructor(definition: D, groupDefinition?: G | undefined);
}
export declare class ValidationMessage {
    message: string;
    constructor(message: string);
}
export declare class ProcessValue<V> {
    value: V;
    constructor(value: V);
}
export declare type ProcessResponse<V> = ProcessValue<V> | ValidationMessage;
export interface ProcessOptions {
    ignoreRequired?: boolean;
}
export declare class Field<R, V> {
    options?: FieldOptions<R, V, any, any> | undefined;
    rawValidators: Validator<R>[];
    validators: Validator<V>[];
    conversionError: ConversionErrorType;
    requiredError?: string | ErrorFunc;
    required: boolean;
    getRaw: RawGetter<R>;
    derivedFunc?: Derived<V>;
    changeFunc?: Change<V>;
    controlled: Controlled;
    postprocess: boolean;
    _converter: ConverterOrFactory<R, V>;
    constructor(converter: ConverterOrFactory<R, V>, options?: FieldOptions<R, V, any, any> | undefined);
    get converter(): IConverter<R, V>;
    createDefaultControlled(): Controlled;
    get RawType(): R;
    get ValueType(): V;
    getConversionError(conversionError: ConversionError, context: any): string;
    isRequired(raw: R, required: boolean, options: ProcessOptions | undefined): boolean;
    process(raw: R, stateConverterOptions: StateConverterOptionsWithContext): ProcessResponse<V>;
    render(value: V, stateConverterOptions: StateConverterOptionsWithContext): R;
}
export declare class RepeatingForm<D extends FormDefinition<any>, G extends GroupDefinition<D>> {
    definition: D;
    groupDefinition?: G | undefined;
    constructor(definition: D, groupDefinition?: G | undefined);
}
export interface GroupOptions<D extends FormDefinition<any>> {
    include?: (keyof D)[];
    exclude?: (keyof D)[];
}
export declare class Group<D extends FormDefinition<any>> {
    options: GroupOptions<D>;
    constructor(options: GroupOptions<D>);
}
export declare function errorMessage(message: string | ErrorFunc, context: any): string;
