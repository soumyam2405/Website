{"ast":null,"code":"/* eslint-disable import/no-cycle */\nimport { types } from \"mobx-state-tree\";\nimport { delay } from \"../../common/state/delay\";\nimport { MessageModel } from \"../message/state/models/MessageModel\";\nimport { WebhookModel } from \"../webhook/WebhookModel\";\nexport const EditorManager = types.model(\"EditorManager\", {\n  messages: types.array(types.late(() => MessageModel)),\n  targets: types.array(types.late(() => WebhookModel))\n}).actions(self => ({\n  set(key, value) {\n    self[key] = value;\n  },\n\n  clear() {\n    self.messages.clear();\n    self.messages.push(MessageModel.create());\n  },\n\n  async save() {\n    for (const target of self.targets) {\n      for (const message of self.messages) {\n        const headers = {\n          \"Accept\": \"application/json\",\n          \"Accept-Language\": \"en\"\n        };\n        const body = message.body;\n\n        if (typeof body === \"string\") {\n          headers[\"Content-Type\"] = \"application/json\";\n        }\n        /* eslint-disable no-await-in-loop */\n\n\n        const [method, url] = await target.getRoute(message.reference);\n        const response = await fetch(url, {\n          method,\n          headers,\n          body\n        });\n        const data = await response.json();\n\n        if (response.headers.get(\"X-RateLimit-Remaining\") === \"0\") {\n          var _response$headers$get;\n\n          const retryAfter = Number((_response$headers$get = response.headers.get(\"X-RateLimit-Reset-After\")) !== null && _response$headers$get !== void 0 ? _response$headers$get : 2) * 1000;\n          console.log(\"Rate limited: delaying next request by\", retryAfter, \"milliseconds\");\n          await delay(retryAfter);\n        }\n        /* eslint-enable no-await-in-loop */\n\n\n        console.log(\"Target executed\", data);\n      }\n    }\n\n    return null;\n  },\n\n  async process(path) {\n    const match = /^\\/targets\\/(\\d+)\\/url$/.exec(path);\n\n    if (match) {\n      var _target$exists;\n\n      const target = self.targets[Number(match[1])];\n      await target.fetch();\n\n      if ((_target$exists = target.exists) !== null && _target$exists !== void 0 ? _target$exists : true) {\n        return {\n          errorValidations: [{\n            id: \"target\",\n            messages: []\n          }]\n        };\n      }\n\n      return {\n        errorValidations: [{\n          id: \"target\",\n          messages: [{\n            path,\n            message: \"Webhook does not exist\"\n          }]\n        }]\n      };\n    }\n\n    return {};\n  }\n\n})); // eslint-disable-next-line @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions","map":{"version":3,"sources":["F:/DiscordHookSite/modules/editor/EditorManager.ts"],"names":["types","delay","MessageModel","WebhookModel","EditorManager","model","messages","array","late","targets","actions","self","set","key","value","clear","push","create","save","target","message","headers","body","method","url","getRoute","reference","response","fetch","data","json","get","retryAfter","Number","console","log","process","path","match","exec","exists","errorValidations","id"],"mappings":"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","sourcesContent":["/* eslint-disable import/no-cycle */\r\n\r\nimport { Instance, SnapshotOrInstance, types } from \"mobx-state-tree\"\r\nimport { delay } from \"../../common/state/delay\"\r\nimport { MessageModel } from \"../message/state/models/MessageModel\"\r\nimport { WebhookModel } from \"../webhook/WebhookModel\"\r\n\r\nexport const EditorManager = types\r\n  .model(\"EditorManager\", {\r\n    messages: types.array(types.late(() => MessageModel)),\r\n    targets: types.array(types.late(() => WebhookModel)),\r\n  })\r\n  .actions(self => ({\r\n    set<K extends keyof typeof self>(\r\n      key: K,\r\n      value: SnapshotOrInstance<typeof self[K]>,\r\n    ) {\r\n      self[key] = value\r\n    },\r\n\r\n    clear() {\r\n      self.messages.clear()\r\n      self.messages.push(MessageModel.create())\r\n    },\r\n\r\n    async save() {\r\n      for (const target of self.targets) {\r\n        for (const message of self.messages) {\r\n          const headers: Record<string, string> = {\r\n            \"Accept\": \"application/json\",\r\n            \"Accept-Language\": \"en\",\r\n          }\r\n\r\n          const body = message.body\r\n          if (typeof body === \"string\") {\r\n            headers[\"Content-Type\"] = \"application/json\"\r\n          }\r\n\r\n          /* eslint-disable no-await-in-loop */\r\n\r\n          const [method, url] = await target.getRoute(message.reference)\r\n\r\n          const response = await fetch(url, { method, headers, body })\r\n          const data = await response.json()\r\n\r\n          if (response.headers.get(\"X-RateLimit-Remaining\") === \"0\") {\r\n            const retryAfter =\r\n              Number(response.headers.get(\"X-RateLimit-Reset-After\") ?? 2) *\r\n              1000\r\n\r\n            console.log(\r\n              \"Rate limited: delaying next request by\",\r\n              retryAfter,\r\n              \"milliseconds\",\r\n            )\r\n\r\n            await delay(retryAfter)\r\n          }\r\n\r\n          /* eslint-enable no-await-in-loop */\r\n\r\n          console.log(\"Target executed\", data)\r\n        }\r\n      }\r\n\r\n      return null\r\n    },\r\n\r\n    async process(path: string) {\r\n      const match = /^\\/targets\\/(\\d+)\\/url$/.exec(path)\r\n      if (match) {\r\n        const target = self.targets[Number(match[1])]\r\n\r\n        await target.fetch()\r\n        if (target.exists ?? true) {\r\n          return { errorValidations: [{ id: \"target\", messages: [] }] }\r\n        }\r\n\r\n        return {\r\n          errorValidations: [\r\n            {\r\n              id: \"target\",\r\n              messages: [{ path, message: \"Webhook does not exist\" }],\r\n            },\r\n          ],\r\n        }\r\n      }\r\n\r\n      return {}\r\n    },\r\n  }))\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions\r\nexport interface EditorManagerLike extends Instance<typeof EditorManager> {}\r\n"]},"metadata":{},"sourceType":"module"}