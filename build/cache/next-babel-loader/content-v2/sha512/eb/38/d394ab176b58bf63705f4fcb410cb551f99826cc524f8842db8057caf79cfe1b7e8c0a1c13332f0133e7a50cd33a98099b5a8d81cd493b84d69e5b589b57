{"ast":null,"code":"/* eslint-disable import/no-cycle */\nimport { flow, types } from \"mobx-state-tree\";\nimport { getUniqueId } from \"../../common/state/uid\";\nimport { BRANDED_DEFAULT_AVATAR_URL, DEFAULT_AVATAR_URL, DEFAULT_DISPLAY_NAME, DISCORD_API_HOST_PROMISE, DISCORD_AVATARS_CDN_BASE_URL, MESSAGE_REF_RE } from \"./constants\";\nexport const WebhookModel = types.model(\"WebhookModel\", {\n  id: types.optional(types.identifierNumber, getUniqueId),\n  url: \"\"\n}).volatile(() => ({\n  exists: undefined,\n  snowflake: undefined,\n  name: undefined,\n  avatar: undefined,\n  channelId: undefined,\n  guildId: undefined,\n  token: undefined\n})).views(self => ({\n  get avatarUrl() {\n    if (!self.avatar) return self.avatar;\n    return `${DISCORD_AVATARS_CDN_BASE_URL}/${self.snowflake}/${self.avatar}.png`;\n  },\n\n  get displayName() {\n    var _self$name;\n\n    return (_self$name = self.name) !== null && _self$name !== void 0 ? _self$name : DEFAULT_DISPLAY_NAME;\n  },\n\n  get displayAvatarUrl() {\n    var _this$avatarUrl;\n\n    return (_this$avatarUrl = this.avatarUrl) !== null && _this$avatarUrl !== void 0 ? _this$avatarUrl : self.avatar === null ? DEFAULT_AVATAR_URL : BRANDED_DEFAULT_AVATAR_URL;\n  },\n\n  async getRoute(reference) {\n    const host = await DISCORD_API_HOST_PROMISE;\n    const match = reference && MESSAGE_REF_RE.exec(reference);\n\n    if (match) {\n      const [, messageId] = match;\n      return [\"PATCH\", `https://${host}/api/v8/webhooks/${self.snowflake}/${self.token}/messages/${messageId}`];\n    }\n\n    return [\"POST\", `https://${host}/api/v8/webhooks/${self.snowflake}/${self.token}?wait=true`];\n  }\n\n})).actions(self => ({\n  set(key, value) {\n    self[key] = value;\n  },\n\n  fetch: flow(function* () {\n    self.exists = undefined;\n    self.snowflake = undefined;\n    self.name = undefined;\n    self.avatar = undefined;\n    self.channelId = undefined;\n    self.guildId = undefined;\n    self.token = undefined;\n\n    try {\n      const url = new URL(self.url);\n      url.host = yield DISCORD_API_HOST_PROMISE;\n      const response = yield fetch(String(url));\n      /* eslint-disable require-atomic-updates */\n\n      if (!response.ok) {\n        self.exists = false;\n        return;\n      }\n\n      const webhook = yield response.json();\n      self.exists = true;\n      self.snowflake = webhook.id;\n      self.name = webhook.name;\n      self.avatar = webhook.avatar;\n      self.channelId = webhook.channel_id;\n      self.guildId = webhook.guild_id;\n      self.token = webhook.token;\n      /* eslint-enable require-atomic-updates */\n    } catch {// do nothing\n    }\n  })\n})); // eslint-disable-next-line @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions","map":{"version":3,"sources":["F:/DiscordHookSite/modules/webhook/WebhookModel.ts"],"names":["flow","types","getUniqueId","BRANDED_DEFAULT_AVATAR_URL","DEFAULT_AVATAR_URL","DEFAULT_DISPLAY_NAME","DISCORD_API_HOST_PROMISE","DISCORD_AVATARS_CDN_BASE_URL","MESSAGE_REF_RE","WebhookModel","model","id","optional","identifierNumber","url","volatile","exists","undefined","snowflake","name","avatar","channelId","guildId","token","views","self","avatarUrl","displayName","displayAvatarUrl","getRoute","reference","host","match","exec","messageId","actions","set","key","value","fetch","URL","response","String","ok","webhook","json","channel_id","guild_id"],"mappings":"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","sourcesContent":["/* eslint-disable import/no-cycle */\r\n\r\nimport { flow, Instance, SnapshotOrInstance, types } from \"mobx-state-tree\"\r\nimport { getUniqueId } from \"../../common/state/uid\"\r\nimport {\r\n  BRANDED_DEFAULT_AVATAR_URL,\r\n  DEFAULT_AVATAR_URL,\r\n  DEFAULT_DISPLAY_NAME,\r\n  DISCORD_API_HOST_PROMISE,\r\n  DISCORD_AVATARS_CDN_BASE_URL,\r\n  MESSAGE_REF_RE,\r\n} from \"./constants\"\r\nimport type { WebhookData } from \"./WebhookData\"\r\n\r\nexport const WebhookModel = types\r\n  .model(\"WebhookModel\", {\r\n    id: types.optional(types.identifierNumber, getUniqueId),\r\n    url: \"\",\r\n  })\r\n  .volatile(() => ({\r\n    exists: undefined as boolean | undefined,\r\n    snowflake: undefined as string | undefined,\r\n    name: undefined as string | undefined,\r\n    avatar: undefined as string | null | undefined,\r\n    channelId: undefined as string | undefined,\r\n    guildId: undefined as string | undefined,\r\n    token: undefined as string | undefined,\r\n  }))\r\n  .views(self => ({\r\n    get avatarUrl() {\r\n      if (!self.avatar) return self.avatar\r\n      return `${DISCORD_AVATARS_CDN_BASE_URL}/${self.snowflake}/${self.avatar}.png`\r\n    },\r\n\r\n    get displayName() {\r\n      return self.name ?? DEFAULT_DISPLAY_NAME\r\n    },\r\n\r\n    get displayAvatarUrl() {\r\n      return (\r\n        this.avatarUrl ??\r\n        (self.avatar === null ? DEFAULT_AVATAR_URL : BRANDED_DEFAULT_AVATAR_URL)\r\n      )\r\n    },\r\n\r\n    async getRoute(reference?: string) {\r\n      const host = await DISCORD_API_HOST_PROMISE\r\n\r\n      const match = reference && MESSAGE_REF_RE.exec(reference)\r\n\r\n      if (match) {\r\n        const [, messageId] = match\r\n\r\n        return [\r\n          \"PATCH\",\r\n          `https://${host}/api/v8/webhooks/${self.snowflake}/${self.token}/messages/${messageId}`,\r\n        ]\r\n      }\r\n\r\n      return [\r\n        \"POST\",\r\n        `https://${host}/api/v8/webhooks/${self.snowflake}/${self.token}?wait=true`,\r\n      ]\r\n    },\r\n  }))\r\n  .actions(self => ({\r\n    set<K extends keyof typeof self>(\r\n      key: K,\r\n      value: SnapshotOrInstance<typeof self[K]>,\r\n    ) {\r\n      self[key] = value\r\n    },\r\n\r\n    fetch: flow(function* () {\r\n      self.exists = undefined\r\n      self.snowflake = undefined\r\n      self.name = undefined\r\n      self.avatar = undefined\r\n      self.channelId = undefined\r\n      self.guildId = undefined\r\n      self.token = undefined\r\n\r\n      try {\r\n        const url = new URL(self.url)\r\n        url.host = yield DISCORD_API_HOST_PROMISE\r\n\r\n        const response: Response = yield fetch(String(url))\r\n\r\n        /* eslint-disable require-atomic-updates */\r\n\r\n        if (!response.ok) {\r\n          self.exists = false\r\n          return\r\n        }\r\n\r\n        const webhook: WebhookData = yield response.json()\r\n\r\n        self.exists = true\r\n        self.snowflake = webhook.id\r\n        self.name = webhook.name\r\n        self.avatar = webhook.avatar\r\n        self.channelId = webhook.channel_id\r\n        self.guildId = webhook.guild_id\r\n        self.token = webhook.token\r\n\r\n        /* eslint-enable require-atomic-updates */\r\n      } catch {\r\n        // do nothing\r\n      }\r\n    }),\r\n  }))\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions\r\nexport interface WebhookLike extends Instance<typeof WebhookModel> {}\r\n"]},"metadata":{},"sourceType":"module"}