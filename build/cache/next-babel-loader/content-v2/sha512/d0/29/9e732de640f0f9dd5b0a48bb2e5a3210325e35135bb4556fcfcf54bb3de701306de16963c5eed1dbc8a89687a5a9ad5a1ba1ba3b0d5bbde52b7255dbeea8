{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport _defineProperty from \"F:/DiscordHookSite/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from \"react\";\nimport { defaultRules } from \"simple-markdown\";\nimport { BlockQuote } from \"../styles/BlockQuote\";\nconst BEGINNING_OF_LINE_RE = /^$|\\n *$/;\nconst BLOCK_QUOTE_RE = /^( *>>> +([\\S\\s]*))|^( *>(?!>>) +[^\\n]*(\\n *>(?!>>) +[^\\n]*)*\\n?)/;\nconst SINGLELINE_QUOTE_RE = /^ *> ?/gm;\nconst MULTILINE_QUOTE_RE = /^ *>>> ?/;\nexport const blockQuote = _objectSpread(_objectSpread({}, defaultRules.blockQuote), {}, {\n  match: (source, state) => {\n    var _lookbehind$;\n\n    const {\n      nested,\n      inQuote,\n      prevCapture: lookbehind\n    } = state; // Prevents having multiple layers of quote blocks\n\n    if (nested) return null;\n    if (inQuote) return null; // Makes sure that quotes can only start on the beginning of a line\n\n    if (!BEGINNING_OF_LINE_RE.test((_lookbehind$ = lookbehind === null || lookbehind === void 0 ? void 0 : lookbehind[0]) !== null && _lookbehind$ !== void 0 ? _lookbehind$ : \"\")) return null;\n    return BLOCK_QUOTE_RE.exec(source);\n  },\n  parse: (capture, parse, state) => {\n    const [content] = capture;\n    const {\n      inline = false\n    } = state; // Determine whether or not the quote block is multi-line\n\n    const multiline = MULTILINE_QUOTE_RE.test(capture[0]); // Removes the '>' symbols from content\n\n    const trimRegex = multiline ? MULTILINE_QUOTE_RE : SINGLELINE_QUOTE_RE;\n    const trimmedContent = content.replace(trimRegex, \"\"); // Parses the trimmed content for any markdown\n\n    const parsedContent = parse(trimmedContent, _objectSpread(_objectSpread({}, state), {}, {\n      inline: multiline ? inline : true,\n      inQuote: true\n    })); // Makes sure the block quote always renders, even without content\n\n    if (parsedContent.length === 0) {\n      parsedContent.push({\n        type: \"text\",\n        content: \" \"\n      });\n    }\n\n    return {\n      content: parsedContent\n    };\n  },\n  react: (node, output, state) => /*#__PURE__*/_jsx(BlockQuote, {\n    children: output(node.content, state)\n  }, state.key)\n});","map":{"version":3,"sources":["F:/DiscordHookSite/modules/markdown/rules/blockQuote.tsx"],"names":["React","defaultRules","BlockQuote","BEGINNING_OF_LINE_RE","BLOCK_QUOTE_RE","SINGLELINE_QUOTE_RE","MULTILINE_QUOTE_RE","blockQuote","match","source","state","nested","inQuote","prevCapture","lookbehind","test","exec","parse","capture","content","inline","multiline","trimRegex","trimmedContent","replace","parsedContent","length","push","type","react","node","output","key"],"mappings":";;;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,YAAT,QAA6B,iBAA7B;AAEA,SAASC,UAAT,QAA2B,sBAA3B;AAEA,MAAMC,oBAAoB,GAAG,UAA7B;AACA,MAAMC,cAAc,GAAG,mEAAvB;AAEA,MAAMC,mBAAmB,GAAG,UAA5B;AACA,MAAMC,kBAAkB,GAAG,UAA3B;AAEA,OAAO,MAAMC,UAAwB,mCAChCN,YAAY,CAACM,UADmB;AAEnCC,EAAAA,KAAK,EAAE,CAACC,MAAD,EAASC,KAAT,KAAmB;AAAA;;AACxB,UAAM;AAAEC,MAAAA,MAAF;AAAUC,MAAAA,OAAV;AAAmBC,MAAAA,WAAW,EAAEC;AAAhC,QAA+CJ,KAArD,CADwB,CAGxB;;AACA,QAAIC,MAAJ,EAAY,OAAO,IAAP;AACZ,QAAIC,OAAJ,EAAa,OAAO,IAAP,CALW,CAOxB;;AACA,QAAI,CAACT,oBAAoB,CAACY,IAArB,iBAA0BD,UAA1B,aAA0BA,UAA1B,uBAA0BA,UAAU,CAAG,CAAH,CAApC,uDAA6C,EAA7C,CAAL,EAAuD,OAAO,IAAP;AAEvD,WAAOV,cAAc,CAACY,IAAf,CAAoBP,MAApB,CAAP;AACD,GAbkC;AAcnCQ,EAAAA,KAAK,EAAE,CAACC,OAAD,EAAUD,KAAV,EAAiBP,KAAjB,KAA2B;AAChC,UAAM,CAACS,OAAD,IAAYD,OAAlB;AACA,UAAM;AAAEE,MAAAA,MAAM,GAAG;AAAX,QAAqBV,KAA3B,CAFgC,CAIhC;;AACA,UAAMW,SAAS,GAAGf,kBAAkB,CAACS,IAAnB,CAAwBG,OAAO,CAAC,CAAD,CAA/B,CAAlB,CALgC,CAOhC;;AACA,UAAMI,SAAS,GAAGD,SAAS,GAAGf,kBAAH,GAAwBD,mBAAnD;AACA,UAAMkB,cAAc,GAAGJ,OAAO,CAACK,OAAR,CAAgBF,SAAhB,EAA2B,EAA3B,CAAvB,CATgC,CAWhC;;AACA,UAAMG,aAAa,GAAGR,KAAK,CAACM,cAAD,kCACtBb,KADsB;AAEzBU,MAAAA,MAAM,EAAEC,SAAS,GAAGD,MAAH,GAAY,IAFJ;AAGzBR,MAAAA,OAAO,EAAE;AAHgB,OAA3B,CAZgC,CAkBhC;;AACA,QAAIa,aAAa,CAACC,MAAd,KAAyB,CAA7B,EAAgC;AAC9BD,MAAAA,aAAa,CAACE,IAAd,CAAmB;AACjBC,QAAAA,IAAI,EAAE,MADW;AAEjBT,QAAAA,OAAO,EAAE;AAFQ,OAAnB;AAID;;AAED,WAAO;AACLA,MAAAA,OAAO,EAAEM;AADJ,KAAP;AAGD,GA3CkC;AA4CnCI,EAAAA,KAAK,EAAE,CAACC,IAAD,EAAOC,MAAP,EAAerB,KAAf,kBACL,KAAC,UAAD;AAAA,cAA6BqB,MAAM,CAACD,IAAI,CAACX,OAAN,EAAeT,KAAf;AAAnC,KAAiBA,KAAK,CAACsB,GAAvB;AA7CiC,EAA9B","sourcesContent":["import React from \"react\"\r\nimport { defaultRules } from \"simple-markdown\"\r\nimport type { MarkdownRule } from \"../parsers/MarkdownRule\"\r\nimport { BlockQuote } from \"../styles/BlockQuote\"\r\n\r\nconst BEGINNING_OF_LINE_RE = /^$|\\n *$/\r\nconst BLOCK_QUOTE_RE = /^( *>>> +([\\S\\s]*))|^( *>(?!>>) +[^\\n]*(\\n *>(?!>>) +[^\\n]*)*\\n?)/\r\n\r\nconst SINGLELINE_QUOTE_RE = /^ *> ?/gm\r\nconst MULTILINE_QUOTE_RE = /^ *>>> ?/\r\n\r\nexport const blockQuote: MarkdownRule = {\r\n  ...defaultRules.blockQuote,\r\n  match: (source, state) => {\r\n    const { nested, inQuote, prevCapture: lookbehind } = state\r\n\r\n    // Prevents having multiple layers of quote blocks\r\n    if (nested) return null\r\n    if (inQuote) return null\r\n\r\n    // Makes sure that quotes can only start on the beginning of a line\r\n    if (!BEGINNING_OF_LINE_RE.test(lookbehind?.[0] ?? \"\")) return null\r\n\r\n    return BLOCK_QUOTE_RE.exec(source)\r\n  },\r\n  parse: (capture, parse, state) => {\r\n    const [content] = capture\r\n    const { inline = false } = state\r\n\r\n    // Determine whether or not the quote block is multi-line\r\n    const multiline = MULTILINE_QUOTE_RE.test(capture[0])\r\n\r\n    // Removes the '>' symbols from content\r\n    const trimRegex = multiline ? MULTILINE_QUOTE_RE : SINGLELINE_QUOTE_RE\r\n    const trimmedContent = content.replace(trimRegex, \"\")\r\n\r\n    // Parses the trimmed content for any markdown\r\n    const parsedContent = parse(trimmedContent, {\r\n      ...state,\r\n      inline: multiline ? inline : true,\r\n      inQuote: true,\r\n    })\r\n\r\n    // Makes sure the block quote always renders, even without content\r\n    if (parsedContent.length === 0) {\r\n      parsedContent.push({\r\n        type: \"text\",\r\n        content: \" \",\r\n      })\r\n    }\r\n\r\n    return {\r\n      content: parsedContent,\r\n    }\r\n  },\r\n  react: (node, output, state) => (\r\n    <BlockQuote key={state.key}>{output(node.content, state)}</BlockQuote>\r\n  ),\r\n}\r\n"]},"metadata":{},"sourceType":"module"}